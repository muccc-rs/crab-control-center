use profirust::dp;
use profirust::fdl;
use profirust::phy;

// I/O Station Parameters
const IO_STATION_ADDRESS: u8 = 8;

// Bus Parameters
const MASTER_ADDRESS: u8 = 3;
const BUS_DEVICE: &'static str = "/dev/ttyUSB0";
const BAUDRATE: profirust::Baudrate = profirust::Baudrate::B500000;

fn main() {
    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or("info"))
        .format_timestamp_micros()
        .init();

    println!("WAGO 750-343 Remote I/O Station Example");

    let mut dp_master = dp::DpMaster::new(vec![]);

    // Options generated by `gsdtool` using "wagob757.gsd"
    let options = profirust::dp::PeripheralOptions {
        // "WAGO 750-343" by "WAGO Kontakttechnik GmbH"
        ident_number: 0xb757,

        // Global Parameters:
        //   - DP-Watchdog-Base...............: 10 ms
        //   - Restart on K-Bus Failure.......: POWER ON RESET
        //   - Device Diagnosis...............: enabled
        //   - Process Data Representation....: MOTOROLA (MSB-LSB)
        //   - Response to PROFIBUS DP Failure: Output image is cleared
        //   - Response to K-Bus Failure......: PROFIBUS communication stops
        //
        // Selected Modules:
        //   [0] 750-343 No PI Channel
        //   [1] 750-504  4 DO/24 V DC/0.5 A
        //       - Terminal is physically....: plugged
        //       - Substitude Value Channel 1: 0
        //       - Substitude Value Channel 2: 0
        //       - Substitude Value Channel 3: 0
        //       - Substitude Value Channel 4: 0
        //   [2] 750-504  4 DO/24 V DC/0.5 A
        //       - Terminal is physically....: plugged
        //       - Substitude Value Channel 1: 0
        //       - Substitude Value Channel 2: 0
        //       - Substitude Value Channel 3: 0
        //       - Substitude Value Channel 4: 0
        //   [3] 750-504  4 DO/24 V DC/0.5 A
        //       - Terminal is physically....: plugged
        //       - Substitude Value Channel 1: 0
        //       - Substitude Value Channel 2: 0
        //       - Substitude Value Channel 3: 0
        //       - Substitude Value Channel 4: 0
        //   [4] 750-504  4 DO/24 V DC/0.5 A
        //       - Terminal is physically....: plugged
        //       - Substitude Value Channel 1: 0
        //       - Substitude Value Channel 2: 0
        //       - Substitude Value Channel 3: 0
        //       - Substitude Value Channel 4: 0
        //   [5] 750-504  4 DO/24 V DC/0.5 A
        //       - Terminal is physically....: plugged
        //       - Substitude Value Channel 1: 0
        //       - Substitude Value Channel 2: 0
        //       - Substitude Value Channel 3: 0
        //       - Substitude Value Channel 4: 0
        //   [6] 750-402  4 DI/24 V DC/3.0 ms
        //       - Terminal is physically: plugged
        //   [7] 750-466  2 AI/4-20 mA/SE
        //       - Terminal is physically: plugged
        //       - Diagnosis Channel 1...: enabled
        //       - Diagnosis Channel 2...: enabled
        user_parameters: Some(&[
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0xc3, 0x00, 0x00, 0x00, 0x00,
            0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0x2b, 0x00, 0x21, 0x02, 0x00, 0x21, 0x02, 0x00,
            0x21, 0x02, 0x00, 0x21, 0x02, 0x00, 0x21, 0x02, 0x00, 0x21, 0x01, 0x00, 0x2c, 0x50,
            0x11, 0x06,
        ]),
        config: Some(&[0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x10, 0x51]),

        // Set max_tsdr depending on baudrate and assert
        // that a supported baudrate is used.
        max_tsdr: match BAUDRATE {
            profirust::Baudrate::B9600 => 60,
            profirust::Baudrate::B19200 => 60,
            profirust::Baudrate::B93750 => 60,
            profirust::Baudrate::B187500 => 60,
            profirust::Baudrate::B500000 => 100,
            profirust::Baudrate::B1500000 => 150,
            profirust::Baudrate::B3000000 => 250,
            profirust::Baudrate::B6000000 => 350,
            profirust::Baudrate::B12000000 => 550,
            b => panic!("Peripheral \"WAGO 750-343\" does not support baudrate {b:?}!"),
        },

        fail_safe: true,
        ..Default::default()
    };
    let mut buffer_inputs = [0u8; 5];
    let mut buffer_outputs = [0u8; 5];
    let mut buffer_diagnostics = [0u8; 64];
    let io_handle = dp_master.add(
        dp::Peripheral::new(
            IO_STATION_ADDRESS,
            options,
            &mut buffer_inputs[..],
            &mut buffer_outputs[..],
        )
        .with_diag_buffer(&mut buffer_diagnostics[..]),
    );

    let mut fdl = fdl::FdlActiveStation::new(
        fdl::ParametersBuilder::new(MASTER_ADDRESS, BAUDRATE)
            // We use a rather large T_slot time because USB-RS485 converters
            // can induce large delays at times.
            .slot_bits(2500)
            .watchdog_timeout(profirust::time::Duration::from_secs(2))
            .build_verified(&dp_master),
    );
    let sleep_time = std::time::Duration::from_micros(3500);

    println!("Connecting to the bus...");
    let mut phy = phy::SerialPortPhy::new(BUS_DEVICE, fdl.parameters().baudrate);

    let start = profirust::time::Instant::now();

    fdl.set_online();
    dp_master.enter_operate();
    loop {
        let now = profirust::time::Instant::now();
        fdl.poll(now, &mut phy, &mut dp_master);

        let events = dp_master.take_last_events();

        // Get mutable access the the peripheral here so we can interact with it.
        let remoteio = dp_master.get_mut(io_handle);

        if remoteio.is_running() && events.cycle_completed {
            // println!("Inputs: {:?}", remoteio.pi_i());
            {
                let (pi_i, pi_q) = remoteio.pi_both();
                let dc_ok = process_image::tag!(pi_i, X, 0, 0);
                let pressure = pi_i[1] << 8 + pi_i[2];

                println!("DC OK: {dc_ok} PRESSURE: {pressure}");

                {
                    let mut refill_indicator = process_image::tag_mut!(pi_q, X, 4, 1);
                    *refill_indicator = true;
                }

                let mut fault_indicator = process_image::tag_mut!(pi_q, X, 4, 0);
                *fault_indicator = true;
            }

            // Set outputs according to our best intentions
            let elapsed = (now - start).total_millis();
            let i = usize::try_from(elapsed / 100).unwrap() % (16);
            let pi_q = remoteio.pi_q_mut();
            pi_q.fill(0x00);
            pi_q[i / 4] |= 1 << (i % 4);
        }

        std::thread::sleep(sleep_time);
    }
}
